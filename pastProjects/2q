#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct{
    char *elems;
    int maxSize;
    int topStack;
} Stack;

int push( Stack* , char, int);
char pop( Stack* , int);

main( int argc, char *argv[] ){
    Stack myStack;
    myStack.maxSize = 0;
    myStack.topStack = 0;
    // we need to malloc for the first free() in push()
    myStack.elems = (char*)malloc(sizeof(char));

    int flag = 0;
    int numRead, sumRead = 0;
    char stdCh, temp, *line, *lntemp, *errStr, *errTemp;
    char openSet[5] = "<{[(\0";
    char closeSet[5] = ">}])\0";
    line = (char*)malloc( sizeof(char)*301);
    errStr = (char*)malloc( sizeof(char)*301);

    if( argc >= 2 && argv[1][1] == 'd')
	flag = 1; // set the debug mode
    
    while( fgets( line, 300, stdin) != NULL){
	errTemp = errStr;
	lntemp = line;
	while( 0 < sscanf( lntemp, "%c%n", &stdCh, &numRead) ){
	    sumRead += numRead;
	    lntemp += numRead;
	    if( stdCh == 'q')
		return 0;
	    if( strchr( openSet, stdCh) != NULL)
		push( &myStack, stdCh, flag);
	    else if( strchr( closeSet, stdCh) != NULL){
		temp = pop( &myStack, flag);
		switch(stdCh){
		    case '>': stdCh = '<'; break;
		    case '}': stdCh = '{'; break;
		    case ']': stdCh = '['; break;
		    case ')': stdCh = '('; break;
		}
	        if( stdCh != temp){
		    if( myStack.topStack == 0) //missing begging mark " ] "
			sprintf( errTemp, "%*c%n", sumRead, 'M', &numRead);
		    else // not properly closed " < ] "
			sprintf( errTemp, "%*c%n", sumRead, 'X', &numRead);

		    errTemp += numRead;
		    if( temp != '\0')
			push( &myStack, temp, flag);
		    sumRead = 0;
	    	}	
	    }
        } //end while (parse line)
	sumRead = 0;
	printf(";%s", line);
	printf(";%s\n", errStr);
	printf("\ndone parsing line");
    }//end while (line from stdin)
    
    if( myStack.topStack == 0)
	printf("Congrats! the line was balanced!\n");

    return 0;
}

//contains flag for debugging
int push( Stack* S, char toPush, int flag){
    int i;
    char* newStack;
    if(flag)
	printf("PUSH\n");
    //if needed, grow the array
    if( S->maxSize == S->topStack){
	if(flag)
	    printf("\tsize before push: %d\n", S->maxSize);	
	newStack = (char*)malloc( sizeof(char)*((S->maxSize)+2) );
	for( i = 0 ; i < S->maxSize ; ++i)
	    newStack[i] = S->elems[i];
	free(S->elems);
        S->elems = newStack;
	S->maxSize += 2;
	if(flag){
	    printf("\tsize after push: %d\n", S->maxSize);
	    printf("\tvalues copied: %d\n", i);
	}
    }
    if(flag)
	printf("\tvalue to be pushed: %c\n", toPush);
    S->elems[S->topStack] = toPush;
    ++(S->topStack);

    return 1;    
}

//contains flag for debugging
char pop(Stack* S, int flag){
    if( S->topStack <= 0)
	return '\0';

    S->topStack--;

    if(flag){
	printf("POP\tvalue popped: %c\n", S->elems[S->topStack]);
    }
    return S->elems[S->topStack];
}

